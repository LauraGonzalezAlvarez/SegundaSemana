import java.util.Arrays;
/**
 * Clase de utilería para ordenar vectores con los métodos burbuja y quicksort de maneta ascendente.
 *
 * @author Gretty Mosquera <gretymosquera@gmail.com>
 * @version 1.0.0 2022-04-21
 * @since 1.0.0
 */
public class ArraySorter implements ISorter  {
	
	 /**
     * Única instancia de la utilidad array sorter
     *
     * @see "Singleton https://es.wikipedia.org/wiki/Singleton"
     */
    private static ArraySorter instance;
    /*
     * Constructor
     */
    private ArraySorter() {

    }

    /**
     * Método para obtener la única instancia disponible de esta clase
     *
     * @return instance
     * @version 1.0.0 2022-04-21
     * @author Gretty Mosquera <gretymosquera@gmail.com>
     * @since 1.0.0
     */
    public static ArraySorter getInstance() {
        if (instance == null) {
            instance = new ArraySorter();
        }
        return instance;
    }

    @Override
    public double[] bubbleMethodAsc(double[] number) {
        int i;
        boolean flag = true;
        double aux;

        while (flag) {
            flag = false;
            for (i = 0; i < number.length - 1; i++) {
                if (number[i] > number[i + 1]) {
                    aux = number[i];
                    number[i] = number[i + 1];
                    number[i + 1] = aux;
                    flag = true;
                }
            }
        }
        return number;
    }

    @Override
    public void quickSort(double[] number, int start, int end) {
        if (start >= end) {
            return;
        }

        double pivot = number[start];
        int leftLimit = start + 1;
        int rightLimit = end;

        while (leftLimit <= rightLimit) {
            while (leftLimit <= end && number[leftLimit] < pivot) {
                leftLimit++;
            }
            while (rightLimit > start && number[rightLimit] >= pivot) {
                rightLimit--;
            }
            if (leftLimit < rightLimit) {
                double temp = number[leftLimit];
                number[leftLimit] = number[rightLimit];
                number[rightLimit] = temp;
            }
        }
        if (rightLimit > start) {
            double temp = number[start];
            number[start] = number[rightLimit];
            number[rightLimit] = temp;
        }
        this.quickSort(number, start, rightLimit - 1);
        this.quickSort(number, rightLimit + 1, end);
    }

    @Override
    public double[] quickSortAsc(double[] number) {
        double[] arrayCopy = Arrays.copyOf(number, number.length);
        this.quickSort(arrayCopy, 0, arrayCopy.length - 1);
        return arrayCopy;

}
    
}
